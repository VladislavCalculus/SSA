# Практичне заняття №4

## Завдання 1

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

Створимо функцію яка буде викликати malloc та перевіряти його результат. 
В цю функцію будемо передавати наступні параметри для виділення 
пам'яті:
- *SIZE_MAX* та *2^63* - Майже зі 100% шансом дадуть помилку. Якщо 
size_t і дозволяє передати таке число, то сам malloc перевіряє, чи можливо 
виділити стільки пам'яті.
- *2^47* - на більшості систем x84_64 це також буде помилкою, адже процесор 
фізично має лише 48 ліній для адрес.
- *1 Gb* - скоріш за все - спрацює коректно.

**NOTE**: думав зможу виділити більше, вирішив про це почитати. Виявилось, 
що лінукс розділяє навпіл алдресний простір - на користувача та ядро. 
Оскільки маллок працює лише в просторі користувача, він виділяє пам'ять 
лише з цієї половини - і не може зайти на іншу.

### Результат виконання

```
System info: 64-bit architecture
--------------------------------------------------
Trying to allocate SIZE_MAX        (18446744073709551615 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^63 (8 Eb)     (9223372036854775808 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^63 - 1        (9223372036854775807 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^47 (128 Tb)   (140737488355328 bytes)... FAIL: Cannot allocate memory
Trying to allocate 1 Gb            (1073741824 bytes)... SUCCESS
```

## Завдання 2

### Опис завдання

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

### Опис рішення

В завдання є дві умови:
1. Використати malloc з від'ємним аргументом.
2. використати формулу a*b

Виконати обидві ці умови дуже просто - результат множення повинен бути 
більший за INT_MAX. Це відбувається через переповнення числа, що починає 
його обрахунок з найменшої точки - тобто для нас це приблизно -INT_MAX 
(А якщо це був би unsigned int - був би 0). 

**NOTE**: Забув додати, що malloc приймає size_t - який по своїй суті і є
unsigned int, тому передача туди від'ємного числа яке може бути < 0 вже є 
похибкою саме по собі.

Але тепер постає питання чому програма взагалі спрацювала? Відповідь досить 
проста: число інтерпритується по іншому. Тобто, від'ємне число має певний 
набір байтів, і цей набір байтів буде інпретуватися як unsigned число.

Варто розгялнути бітові значення для пояснення цього завдання: 
1. *0xBB800000* - це наше число 1149239296
2. Ключова відмінність 64 та 32 бітних систем полягає ось тут. При перетворенні в: 
	- У 64 бітній системі int < size_t (адже int є 32 бітним). Саме тому 
будуть додані нові байти, які будуть заповнені 0xFF (або ж всі біти - 1). 
В результаті число стає чимось в районі *0xFFFFFFFFBB800000*, що набагато 
більше ніж простір користувача
	- У 32 бітній системі int = size_t в плані кількості бітів, тому 
число не буде доповненим верликою кількістю 1-их бітів. Але проблема не зміниться -
число виходить надто великим для виділення (це приблизно 3Гб), де користувацький простір рівний 2-м.

### Результат виконання

```
xa: 1048576, xb: 3000
Обчислене num: -1149239296
Розмір size_t: 8 байтів
NULL: Помилка: Cannot allocate memory
```

## Завдання 3

### Опис завдання

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

### Опис рішення

На нових версіях Linux використання malloc(0) є повністю безпечним. Причиною 
цього є те, що навіть при виклику функції яка повинна виділити нуль байт - 
вона все одно виділяє маленьку кількість даних, для того щоб отримати 
ідентифікатор, який можна очистити за допомогою free(). Це дає розуміння, що 
виділення пам'яті в будь-якому разі буде мати унікальний номер, і адреси 
виділеної пам'яті між собою пересікатися не будуть.

**NOTE**: навіть якби ми отримали NULL з malloc - free(NULL) все одно є 
безпечним викликом, адже за специфікацією С такий виклик робить рівно нічого.

### Результат виконання

```
malloc(0)
Результат: 0x27da32b0
Звільнення пам'яті
Очищено
```
## Завдання 4

### Опис завдання

Чи є помилки у такому коді?

```
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
```
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

### Опис рішення

Ключова проблема в тому що ptr після free(ptr) не стає знову NULL.

Вся програма працює в циклі, і в кінці циклу ми робимо очищення ивділеної пам'яті. 
Тепер виходить так - пам'яті там вже нема, але ptr досі зберігає адресу. 
І тепер ptr не є NULL (тобто умова if(!ptr) - хибна, ноаий ptr не створюється) 
і коли виконання дійде до використання ptr - це буде робота зі звільненою пам'яттю, що призведе до помилки.

Єдина зміна яку тут варто додати - це рядок *ptr = NULL* після функції free(ptr).

### Результат виконання

###### Виконання коли ptr не звільнено

```
iтерація: 0
Викликаю malloc...
ptr: Дані ітерації
free(ptr)

iтерація: 1
malloc НЕ викликано!: 0x5c2a358386b0
ptr: 8X��
free(ptr)
free(): double free detected in tcache 2
Aborted (core dumped)
```

###### Правильна варіант коду

```
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr) {
        ptr = malloc(n);
	if (!ptr) = break; //Гарною практикою є завжди перевіряти виділення динамічної пам'ятті
    }
    [... <використання 'ptr'> ...]
    free(ptr);
    ptr = NULL;
}
```
## Завдання 5

### Опис завдання

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

### Опис рішення

Коли realloc() не може виділити новий блок пам'яті він повертає NULL ТА (що 
важливо) старий блок пам'яті не звільняється і лишається підходящим для роботи. 

Тобто, якщо функція поверне NULL і ми перезапишемо поінтер на неї - старий 
блок пам'яті досі існує, але доступу до нього вже немає - відбувається витік 
пам'яті.

### Результат виконання

```
malloc: 0x604ece94a2a0
realloc до 4611686018427387904 байтів...
realloc NULL (Cannot allocate memory)
СТАРИЙ блок: 0x604ece94a2a0
```

## Завдання 6

### Опис завдання

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.


### Опис рішення

Тут варто роглянути два варіанти.

1. *realloc(NULL, size)* - при такому виклику функція realloc буде еквівалентна 
функції malloc() - вона просто виділить певний блок пам'ятті.
2. *realloc(ptr, 0)* - ця функція спрацює як еквівалент *free(ptr)*. Вона 
звільнить місце та поверне NULL.

**NOTE**: у результатах можна помітити, що досі є посилання на пам'ять. 
Це службові байти, які працюють ідентично до того, як це було при перевірці 
роботи *malloc(0)*

### Результат виконання

realloc(NULL, 100): 0x61b5e11f32a0
realloc(p1, 0): (nil)
Пам'ять за адресою 0x61b5e11f32a0 звільнена.

## Завдання 7

### Опис завдання

Перепишіть наступний код, використовуючи reallocarray(3):

```
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));
```

Порівняйте результати виконання з використанням ltrace.

### Опис рішення

Функція *reallocarray()* має перевагу над звичайною ф-цією *realloc* 
по причини того, що вона має захист від integer overflow, що дає їй значну 
перевагу, підвищуючи безпеку системи.

Функція *calloc* по своїй роботі схожа на функцію *malloc* але 
її відмінність у тому, що вона ініціалізує пам'ять нулями, поки 
malloc лишає її неініціалізованою.

### Результат виконання

```
calloc(1000, 68)                                 = 0x334512a0
reallocarray(0x334512a0, 500, 68)                = 0x334512a0
puts("\n\320\222\320\270\320\264\321\226\320\273\320\265\320\275\320\276 500 \320\265\320\273\320\265\320\274\320\265"...) = 41
free(0x334512a0)                                 = <void>
+++ exited (status 0) +++

Виділено 500 елементів
```

## Завдання 8

### Опис завдання

Дослідити поведінку realloc() при розширенні блоку. Виявити випадки копіювання та “розширення на місці”.

### Опис рішення

Виконаємо дві варіації виконання цього завдання (вони в одному файлі):

1. **Розширення**: в цьому варіанті ми виділяємо пам'ять та після чого ми 
збільшиом виділену пам'ять за допомогою *realloc*.

2. **Копіювання**: в цьому випадку після виділення пам'яті виділимо ще один 
блок пам'яті для того, щоб за нашим блоком не було місця для розширення - 
в таикй спосіб наша виділена пам'ять буде переміщена в інший блок, де 
достатньо місця.

### Результат виконання

```
puts("\n\320\240\320\276\320\267\321\210\320\270\321\200\320\265\320\275\320\275\321\217") = 22
malloc(128)                                      = 0x3ba172b0
printf("\320\237\320\276\321\207\320\260\321\202\320\272\320\276\320\262\320\260 \320\260\320\264\321\200\320\265\321\201\320\260:"...) = 44
realloc(0x3ba172b0, 256)                         = 0x3ba172b0
printf("\320\235\320\276\320\262\320\260 \320\260\320\264\321\200\320\265\321\201\320\260: %p\n", 0x3ba172b0) = 34
puts("\320\240\320\265\320\267\321\203\320\273\321\214\321\202\320\260\321\202: \320\261\320\273\320\276\320\272 \321\200\320"...) = 48
puts("\n\322\221\321\202\320\232\320\276\320\277\321\226\321\216\320\262\320\260\320\275\320\275\321\217") = 26
malloc(128)                                      = 0x3ba173c0
malloc(128)                                      = 0x3ba17450
printf("\320\237\320\276\321\207\320\260\321\202\320\272\320\276\320\262\320\260 \320\260\320\264\321\200\320\265\321\201\320\260 "...) = 47
printf("\320\220\320\264\321\200\320\265\321\201\320\260 \320\267\320\260\321\202\320\270\321\207\320\272\320\270: %p\n"..., 0x3ba17450) = 40
realloc(0x3ba173c0, 1048576)                     = 0x7961c6cb4010
printf("\320\235\320\276\320\262\320\260 \320\260\320\264\321\200\320\265\321\201\320\260 p2: %p\n", 0x7961c6cb4010) 
Розширення
Початкова адреса: 0x3ba172b0
Нова адреса: 0x3ba172b0
Результат: блок розширено

ґтКопіювання
Початкова адреса p2: 0x3ba173c0
Адреса затички: 0x3ba17450
Нова адреса p2: 0x7961c6cb4010
Результат: дані в новому блоці
= 41
puts("\320\240\320\265\320\267\321\203\320\273\321\214\321\202\320\260\321\202: \320\264\320\260\320\275\321\226 \320\262 "...) = 56
free(0x3ba172b0)                                 = <void>
free(0x3ba17450)                                 = <void>
free(0x7961c6cb4010)                             = <void>
+++ exited (status 0) +++
```
