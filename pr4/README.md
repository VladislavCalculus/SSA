# Практичне заняття №4

## Завдання 1

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

Створимо функцію яка буде викликати malloc та перевіряти його результат. 
В цю функцію будемо передавати наступні параметри для виділення 
пам'яті:
- *SIZE_MAX* та *2^63* - Майже зі 100% шансом дадуть помилку. Якщо 
size_t і дозволяє передати таке число, то сам malloc перевіряє, чи можливо 
виділити стільки пам'яті.
- *2^47* - на більшості систем x84_64 це також буде помилкою, адже процесор 
фізично має лише 48 ліній для адрес.
- *1 Gb* - скоріш за все - спрацює коректно.

**NOTE**: думав зможу виділити більше, вирішив про це почитати. Виявилось, 
що лінукс розділяє навпіл алдресний простір - на користувача та ядро. 
Оскільки маллок працює лише в просторі користувача, він виділяє пам'ять 
лише з цієї половини - і не може зайти на іншу.

### Результат виконання

```
System info: 64-bit architecture
--------------------------------------------------
Trying to allocate SIZE_MAX        (18446744073709551615 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^63 (8 Eb)     (9223372036854775808 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^63 - 1        (9223372036854775807 bytes)... FAIL: Cannot allocate memory
Trying to allocate 2^47 (128 Tb)   (140737488355328 bytes)... FAIL: Cannot allocate memory
Trying to allocate 1 Gb            (1073741824 bytes)... SUCCESS
```

## Завдання 2

### Опис завдання

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

### Опис рішення

В завдання є дві умови:
1. Використати malloc з від'ємним аргументом.
2. використати формулу a*b

Виконати обидві ці умови дуже просто - результат множення повинен бути 
більший за INT_MAX. Це відбувається через переповнення числа, що починає 
його обрахунок з найменшої точки - тобто для нас це приблизно -INT_MAX 
(А якщо це був би unsigned int - був би 0). 

**NOTE**: Забув додати, що malloc приймає size_t - який по своїй суті і є
unsigned int, тому передача туди від'ємного числа яке може бути < 0 вже є 
похибкою саме по собі.

Але тепер постає питання чому програма взагалі спрацювала? Відповідь досить 
проста: число інтерпритується по іншому. Тобто, від'ємне число має певний 
набір байтів, і цей набір байтів буде інпретуватися як unsigned число.

Варто розгялнути бітові значення для пояснення цього завдання: 
1. *0xBB800000* - це наше число 1149239296
2. Ключова відмінність 64 та 32 бітних систем полягає ось тут. При перетворенні в: 
	- У 64 бітній системі int < size_t (адже int є 32 бітним). Саме тому 
будуть додані нові байти, які будуть заповнені 0xFF (або ж всі біти - 1). 
В результаті число стає чимось в районі *0xFFFFFFFFBB800000*, що набагато 
більше ніж простір користувача
	- У 32 бітній системі int = size_t в плані кількості бітів, тому 
число не буде доповненим верликою кількістю 1-их бітів. Але проблема не зміниться -
число виходить надто великим для виділення (це приблизно 3Гб), де користувацький простір рівний 2-м.

### Результат виконання

```
xa: 1048576, xb: 3000
Обчислене num: -1149239296
Розмір size_t: 8 байтів
NULL: Помилка: Cannot allocate memory
```

## Завдання 3

### Опис завдання

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

### Опис рішення

На нових версіях Linux використання malloc(0) є повністю безпечним. Причиною 
цього є те, що навіть при виклику функції яка повинна виділити нуль байт - 
вона все одно виділяє маленьку кількість даних, для того щоб отримати 
ідентифікатор, який можна очистити за допомогою free(). Це дає розуміння, що 
виділення пам'яті в будь-якому разі буде мати унікальний номер, і адреси 
виділеної пам'яті між собою пересікатися не будуть.

**NOTE**: навіть якби ми отримали NULL з malloc - free(NULL) все одно є 
безпечним викликом, адже за специфікацією С такий виклик робить рівно нічого.

### Результат виконання

```
malloc(0)
Результат: 0x27da32b0
Звільнення пам'яті
Очищено
```
## Завдання 4

### Опис завдання

Чи є помилки у такому коді?

```
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
```
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

### Опис рішення

### Результат виконання

## Завдання 5

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

### Результат виконання

## Завдання 6

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

### Результат виконання

## Завдання 7

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

### Результат виконання

## Завдання 8

### Опис завдання

Скільки пам’яті може виділити malloc(3) за один виклик?

### Опис рішення

### Результат виконання
