# Практична робота №2

## Завдання 1
### Опис завдання

Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

### Опис виконання

Для виконання ми маєро розраховувати, що ми можемо мати 
time_t двох типів - 32 та 64 біт. Тому перед початком обрахунків визначимо
який саме з них ми маємо. Оскільки time_t - це число, то задамо його 
максимумом.

*Примітка під час виконання*: ctime() має в собі якийсь обмежувач, тому 
значення типу long в своєму максимумі не є валідним варіантом. 
Прочитавши відкриті джерела, можна вияснити - максимальний допустимий час
для 32-бітної системи є 2038 рік, але в ситуації яка наведена в моєму коді
з типом long - отримуємо NULL, адже ctime() архітектурно повертає 
NULL поінтер коли значення занадто велике щоб він міг його захендлити.

Враховуючи, що ми не можемо знайти максимум просто підставивши число - 
поставимо на місце LLONG_MAX максимальне значення unsigned int, 
та запустимо цикл який буде його збільшувати, щоб наочно побачити результат. 
Цикл буде збільшувати його на 1000000000000, адже всі інші варіанти (протестовано) 
зайють надто багато часу для переповнення.

### Використання

> ./z1

### Результат виконання

Результатом виконання для 64-бітнох системи є *приблизна* нада кінця time_t -
```
Максимальний час (64-біт): Tue Jun 10 23:54:07 2147452780

Максимальний час (64-біт): (null)
```

(null) означає, що ctime() більше не спроможний опрацьовувати значення,
що в нього передали.

## Завдання 2

### Опис завдання

Розглянути сенгменти на прикладі просто виконуваємого файлу.

##### Підзавдання:

- Звичайний файл з "Hello world!"
- Додати до файлу глобальний масив, пустий
- Заповнити глобальний масив
- Зробити масив локальним
- Перевірити зміни при іншому виді компіляції (для прикладу: прапорець -g)

### Опис рішення
Підбиваючи підсумки до завдання можна виділити:

- Сегмент data збільшує фізичний розмір на диску, бо зберігає фактичні дані
- Сегмент BSS збільшує значення в таблиці розмірів, але сам файл при цьому не 
збільшується
- Debug та Оптимізація (-O) не мали помітного впливу на роботу програми

### Результати виконання

Нижче наведені результати команд ls -l та size для кожного з варіантів 
виконання завдання.

##### Підзавдання 1

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 15960 Feb 12 09:07 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	    600	      8	   1984	    7c0	z2
```

##### Підзавдання 2

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 15984 Feb 12 09:14 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	    600	   4032	   6008	   1778	z2
```

##### Підзавдання 3

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 20000 Feb 12 09:16 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	   4616	      8	   6000	   1770	z2
```

##### Підзавдання 4

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 16008 Feb 12 09:17 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1576	    608	      8	   2192	    890	z2
```

##### Підзавдання 5

```
В результаті тестування з ключовим словом -g (Debug) помітних змін за 
допомогою size та ls -l визначити не вдалось
```

## Завдання 3

### Опис завдання

Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.

Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

### Опис рішення

Для вирішення даного завдання нам необзідно утворити певну кількість змінних 
які будуть відповідати на елементи в нашому стеку. Цими змінними будуть:

- int, якому задано певне значення - це буде сегмент даних
- int, який лише проініціалізувати не задавши значення - сегмент BSS
- локальний int для main, який буде вказувати на верхівку стеку 
- динамічно виділений int, яким ми будемо відслідковувати зміни в стеку
- та виведення функції main, яка буде показувати під собою елемент text

Для перевірки змін також буде написана функція, що створює великі масиви 
даних. Функція буде рекурсивна для спрощення збереження масивів.

В результаті виконання цього експерименту можна чітко помітити що:
- Текст та дані знаходяться в самому початку адресного простору
- Купа розсташована трішки вище за сегмент даних
- Стек має велику різницю в адресі - він починаєтсья майже в самому кінці 
виділеної пам'яті.

### Результат виконання

```
Адреси сегментів
Текст (функція main): 0x625635b70240
Дані (global_var): 0x625635b73010
BSS: 0x625635b73018
Купа: 0x62564057d2a0
Початкова вершина стека:0x7ffc6d14a5cc

Ріст стеку
Стек на глибині 1: 0x7ffc6d149600
Стек на глибині 2: 0x7ffc6d148630
Стек на глибині 3: 0x7ffc6d147660

```

## Завдання 4

## Завдання 5

## Завдання 6
