# Практична робота №2

## Завдання 1
### Опис завдання

Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

### Опис виконання

Для виконання ми маєро розраховувати, що ми можемо мати 
time_t двох типів - 32 та 64 біт. Тому перед початком обрахунків визначимо
який саме з них ми маємо. Оскільки time_t - це число, то задамо його 
максимумом.

*Примітка під час виконання*: ctime() має в собі якийсь обмежувач, тому 
значення типу long в своєму максимумі не є валідним варіантом. 
Прочитавши відкриті джерела, можна вияснити - максимальний допустимий час
для 32-бітної системи є 2038 рік, але в ситуації яка наведена в моєму коді
з типом long - отримуємо NULL, адже ctime() архітектурно повертає 
NULL поінтер коли значення занадто велике щоб він міг його захендлити.

Враховуючи, що ми не можемо знайти максимум просто підставивши число - 
поставимо на місце LLONG_MAX максимальне значення unsigned int, 
та запустимо цикл який буде його збільшувати, щоб наочно побачити результат. 
Цикл буде збільшувати його на 1000000000000, адже всі інші варіанти (протестовано) 
зайють надто багато часу для переповнення.

### Використання

> ./z1

### Результат виконання

Результатом виконання для 64-бітнох системи є *приблизна* нада кінця time_t -
```
Максимальний час (64-біт): Tue Jun 10 23:54:07 2147452780

Максимальний час (64-біт): (null)
```

(null) означає, що ctime() більше не спроможний опрацьовувати значення,
що в нього передали.

## Завдання 2

### Опис завдання

Розглянути сенгменти на прикладі просто виконуваємого файлу.

##### Підзавдання:

- Звичайний файл з "Hello world!"
- Додати до файлу глобальний масив, пустий
- Заповнити глобальний масив
- Зробити масив локальним
- Перевірити зміни при іншому виді компіляції (для прикладу: прапорець -g)

### Опис рішення
Підбиваючи підсумки до завдання можна виділити:

- Сегмент data збільшує фізичний розмір на диску, бо зберігає фактичні дані
- Сегмент BSS збільшує значення в таблиці розмірів, але сам файл при цьому не 
збільшується
- Debug та Оптимізація (-O) не мали помітного впливу на роботу програми

### Результати виконання

Нижче наведені результати команд ls -l та size для кожного з варіантів 
виконання завдання.

##### Підзавдання 1

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 15960 Feb 12 09:07 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	    600	      8	   1984	    7c0	z2
```

##### Підзавдання 2

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 15984 Feb 12 09:14 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	    600	   4032	   6008	   1778	z2
```

##### Підзавдання 3

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 20000 Feb 12 09:16 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1376	   4616	      8	   6000	   1770	z2
```

##### Підзавдання 4

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ ls -l z2
-rwxrwxr-x 1 adminmint adminmint 16008 Feb 12 09:17 z2

adminmint@adminmint-VirtualBox:~/asp_u/pr2$ size z2
   text	   data	    bss	    dec	    hex	filename
   1576	    608	      8	   2192	    890	z2
```

##### Підзавдання 5

```
В результаті тестування з ключовим словом -g (Debug) помітних змін за 
допомогою size та ls -l визначити не вдалось
```

## Завдання 3

### Опис завдання

Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.

Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

### Опис рішення

Для вирішення даного завдання нам необзідно утворити певну кількість змінних 
які будуть відповідати на елементи в нашому стеку. Цими змінними будуть:

- int, якому задано певне значення - це буде сегмент даних
- int, який лише проініціалізувати не задавши значення - сегмент BSS
- локальний int для main, який буде вказувати на верхівку стеку 
- динамічно виділений int, яким ми будемо відслідковувати зміни в стеку
- та виведення функції main, яка буде показувати під собою елемент text

Для перевірки змін також буде написана функція, що створює великі масиви 
даних. Функція буде рекурсивна для спрощення збереження масивів.

В результаті виконання цього експерименту можна чітко помітити що:
- Текст та дані знаходяться в самому початку адресного простору
- Купа розсташована трішки вище за сегмент даних
- Стек має велику різницю в адресі - він починаєтсья майже в самому кінці 
виділеної пам'яті.

### Результат виконання

```
Адреси сегментів
Текст (функція main): 0x625635b70240
Дані (global_var): 0x625635b73010
BSS: 0x625635b73018
Купа: 0x62564057d2a0
Початкова вершина стека:0x7ffc6d14a5cc

Ріст стеку
Стек на глибині 1: 0x7ffc6d149600
Стек на глибині 2: 0x7ffc6d148630
Стек на глибині 3: 0x7ffc6d147660

```

## Завдання 4

### Опис завдання

Ваше завдання - дослідити стек процесу або пригадати, як це робиться.

### Опис рішення

В даному завданні важливо скомпілювати програму з увімкненим Debug. 
Тобто, компіляція буде виклядати як:

> gcc -Wall -g z4.c -o z4

Після компіляції запускаємо програму в окремому вікні терміналу - 
вона повинна працювати у фоні, щоб ми могли проаналізувати до цього процесу. 

> ./z4 &

Тепер, в окремому терміналі нам необідно знайти ідентифікатор процесу 
за допомогою команди pidof

>pidof z4

*Приклад*:

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ pidof z4
3941
```

Результатом виконання буде число. За допомогою нього ми можемо підключитися 
до процесу, але оскільки Ubuntu має захист процесів - підключатися варто за 
допомогою sudo.

> sudo gdb -q -p {PROSSES_NUM}

В результаті можна буде побачити стек від #0 (pause) і до #4 (main).

*Приклад*:

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ sudo gdb -q -p 3941
[sudo] password for adminmint:       
Attaching to process 3941
Reading symbols from /home/adminmint/asp_u/pr2/z4...
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...
Reading symbols from /usr/lib/debug/.build-id/27/4eec488d230825a136fa9c4d85370fed7a0a5e.debug...
Reading symbols from /lib64/ld-linux-x86-64.so.2...
Reading symbols from /usr/lib/debug/.build-id/52/0e05878220fb2fc6d28ff46b63b3fd5d48e763.debug...
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
0x00007a1145efa3d4 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:29

warning: 29	../sysdeps/unix/sysv/linux/pause.c: No such file or directory
(gdb) bt
#0  0x00007a1145efa3d4 in __libc_pause ()
    at ../sysdeps/unix/sysv/linux/pause.c:29
#1  0x000060579f72b224 in bar_is_now_closed () at z4.c:12
#2  0x000060579f72b287 in bar () at z4.c:18
#3  0x000060579f72b2ea in foo () at z4.c:24
#4  0x000060579f72b354 in main (argc=1, argv=0x7ffe6cdc8088) at z4.c:30
(gdb) quit
A debugging session is active.

	Inferior 1 [process 3941] will be detached.

Quit anyway? (y or n) y
Detaching from program: /home/adminmint/asp_u/pr2/z4, process 3941
[Inferior 1 (process 3941) detached]

```

Наступним кроком буде дослідження за допомогою gstack, аналогічно 
минулому варіанту - запуск виконується через sudo.

> sudo gstack {PROSSES_NUM}

*NOTE*: gstack може бути відсутній на машині, тому можливо його доведеться 
доставити вручну (як, наприклад, на цьому Linux Mint)

Важливо примітити, що між gstack і захистом Ubuntu може бути конфлікт - 
в такому разі варто досліджувати мануальним шляхом, як наведено вище.
Прикладом такого є локальна машина на якій виконувалася ця лабораторна, 
адже вона не пропускає автоматичний gtack (в моєму разі pstack) до процесу.

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ sudo pstack 3941

3941: ./z4
pstack: Input/output error
failed to read target.

```

## Завдання 5

### Опис завдання

Відомо, що при виклику процедур і поверненні з них процесор
використовує стек.Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.

### Опис

Якщо вирішити повністю замінити індекс поінтер (надалі IP) вершиною стека 
ми б отримали декліка проблем;
- Кожна існтрукція після виконання мала б використовувати pop для 
отримання наступної інструкції зі стеку та передвати її в процесор
- В результаті такого підходу програма б виглядала не як лінійний набір 
комад, але як стек адрес

В цілому, хоч ця ідея і теоретично можлива, але в неї є сильні недоліки. 
- **Втрата лінійності та збільшення об'єму використаної пам'яті** 
При класичному IP він автоматично інкрементується, що дозволяє зберігати 
команди послідовно, якщо ж кожна наступна адреса лежатиме на стеку то 
для кожної 1-о байтової команди доведеться збергіати 8-и байтову адресу, 
що збільшить витрати пам'яті.

- **Змішування даних та керування** Стек використовується для передачі 
аргументів та зберігання локальних мінних, і якщо так само зберігати і 
шлях викоанння програми, то будь-яка помилка в логіці призведе до виконання 
даних замість команди. Це зробить систему вразливою.

Як приклад можна навести машини Forth. Мова програмування Forth та процесори, 
що її підтримують, наближені до такої ідеї. Вони використовують стек для всього, 
але там є прихїований механізм відстеження поточної команди. 

### Відповідь

Така ідея є не вартою затрит ресурсів. Вона сповільнить загальне виконання 
команд, збільшить використання пам'яті та зробить систему менш безпечною для використання.

## Завдання 6

### Опис завдання

Аналізуйте поведінку динамічних бібліотек під час завантаження.

### Опис рішення

```
adminmint@adminmint-VirtualBox:~/asp_u/pr2$ LD_DEBUG=libs ./z4
      5541:	find library=libc.so.6 [0]; searching
      5541:	 search cache=/etc/ld.so.cache
      5541:	  trying file=/lib/x86_64-linux-gnu/libc.so.6
      5541:	
      5541:	
      5541:	calling init: /lib64/ld-linux-x86-64.so.2
      5541:	
      5541:	
      5541:	calling init: /lib/x86_64-linux-gnu/libc.so.6
      5541:	
      5541:	
      5541:	initialize program: ./z4
      5541:	
      5541:	
      5541:	transferring control: ./z4
      5541:	
In function                 main; &amp;localvar = 0x7fff0a1668e4
In function                  foo; &amp;localvar = 0x7fff0a1668b4
In function                  bar; &amp;localvar = 0x7fff0a166894
In function    bar_is_now_closed; &amp;localvar = 0x7fff0a166874

 Now blocking on pause()...

```

Розглянемо вирішення завдання на цьому прикладі, розбираючи його поетапно.

- *find library=libc.so.6 [0]; searching*: програма z4 залежить від 
стандартної бібліотеки мови С (вона ж libc.so.6). 
Завантажувач шукає та успішно знаходить файл за шляхом
*file=/lib/x86_64-linux-gnu/libc.so.6*
- *calling init: /lib64/ld-linux-x86-64.so.2*: завантажувач виконує 
конструктори та внутрішню ініціалізацію самих бібліотек. якщо глянуни 
лог на однйи рядок нижче (*calling init: /lib/x86_64-linux-gnu/libc.so.6*) 
то можна побачити що спочатку ініціалізується завантажувач, а потім - 
бібліотека libc.
- *transferring control: ./z4*: підготовка середовища для запуску завершено, 
і процесор починає виконувати інструкції з main. Все що йде нижче - 
вже виконання програми, яку можна переглянуди в завдання 4.
